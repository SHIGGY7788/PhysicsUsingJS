{
  "version": 3,
  "sources": ["../../three.interaction/src/utils/Utils.js", "../../three.interaction/src/patch/EventDispatcher.js", "../../three.interaction/src/patch/Object3D.js", "../../three.interaction/src/interaction/InteractionData.js", "../../three.interaction/src/interaction/InteractionEvent.js", "../../three.interaction/src/interaction/InteractionTrackingData.js", "../../three.interaction/src/interaction/InteractionManager.js", "../../three.interaction/src/interaction/InteractionLayer.js", "../../three.interaction/src/utils/Raf.js", "../../three.interaction/src/utils/Ticker.js", "../../three.interaction/src/interaction/Interaction.js"],
  "sourcesContent": ["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n", "import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n", "import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n", "import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n", "/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n    this.intersects = [];\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersects = [];\n  }\n}\n\nexport default InteractionEvent;\n", "/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n", "import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n", "import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionLayer extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n    this.layer = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isAble() {\n    return this.layer && this.layer.interactive;\n  }\n\n  /**\n   * set layer\n   * @param {Layer} layer layer\n   */\n  setLayer(layer) {\n    this.layer = layer;\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    if (!this.isAble()) return null;\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.layer.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    if (!this.isAble()) return;\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.layer.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (!this.isAble()) return;\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.layer.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    if (!this.isAble()) return;\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionLayer;\n", "(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n", "import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n", "import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"],
  "mappings": "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",
  "names": ["_rt", "val", "Object", "prototype", "toString", "call", "Utils", "ks", "variable", "EventDispatcher", "on", "type", "fn", "isFunction", "Object3D", "interactive", "addEventListener", "off", "removeEventListener", "once", "cb", "ev", "emit", "_listeners", "undefined", "isUndefined", "cbs", "cache", "slice", "argument", "i", "length", "apply", "interactiveChildren", "started", "defineProperty", "_trackedPointers", "raycastTest", "raycaster", "result", "raycast", "InteractionData", "global", "Vector2", "target", "originalEvent", "identifier", "isPrimary", "button", "buttons", "width", "height", "tiltX", "tiltY", "pointerType", "pressure", "rotationAngle", "twist", "tangentialPressure", "event", "InteractionEvent", "stopped", "currentTarget", "data", "intersects", "InteractionTrackingData", "pointerId", "_pointerId", "_flags", "FLAGS", "NONE", "flag", "yn", "flags", "constructor", "OVER", "_doSet", "RIGHT_DOWN", "LEFT_DOWN", "freeze", "MOUSE_POINTER_ID", "hitTestEvent", "InteractionManager", "renderer", "scene", "camera", "options", "autoPreventDefault", "interactionFrequency", "mouse", "set", "activeInteractionData", "interactionDataPool", "eventData", "interactionDOMElement", "moveWhenInside", "eventsAdded", "mouseOverRenderer", "supportsTouchEvents", "window", "supportsPointerEvents", "PointerEvent", "onClick", "bind", "processClick", "onPointerUp", "processPointerUp", "onPointerCancel", "processPointerCancel", "onPointerDown", "processPointerDown", "onPointerMove", "processPointerMove", "onPointerOut", "processPointerOverOut", "onPointerOver", "cursorStyles", "currentCursorMode", "cursor", "Raycaster", "_deltaTime", "setTargetElement", "domElement", "globalPoint", "root", "processInteractive", "element", "removeEvents", "addEvents", "navigator", "msPointerEnabled", "style", "document", "snippet", "didMove", "k", "hasOwnProperty", "interactionData", "interactionEvent", "configureInteractionEventForDOMEvent", "setCursorMode", "mode", "assign", "displayObject", "eventString", "func", "hitTest", "visible", "hit", "interactiveParent", "children", "child", "childHit", "parent", "object", "events", "normalizeToPointerData", "isNormalized", "preventDefault", "getInteractionDataForPointerId", "triggerEvent", "eventLen", "isRightButton", "id", "trackedPointers", "rightDown", "leftDown", "cancelled", "eventAppend", "releaseInteractionDataForPointerId", "onPointerComplete", "trackingData", "isTouch", "isMouse", "test", "isDown", "over", "none", "pop", "_copyEvent", "_reset", "push", "point", "x", "y", "rect", "parentElement", "getBoundingClientRect", "left", "top", "pointerEvent", "mapPositionToPoint", "clientX", "clientY", "setFromCamera", "globalX", "globalY", "intersectObjects", "normalizedEvents", "TouchEvent", "li", "changedTouches", "touch", "touches", "radiusX", "radiusY", "force", "layerX", "offsetX", "layerY", "offsetY", "MouseEvent", "removeAllListeners", "_tempPoint", "InteractionLayer", "layer", "isAble", "lastTime", "vendors", "requestAnimationFrame", "cancelAnimationFrame", "callback", "currTime", "Date", "getTime", "timeToCall", "Math", "max", "setTimeout", "RAF", "CAF", "Ticker", "timer", "pt", "start", "loop", "timeline", "now", "Interaction", "autoAttach", "ticker", "update"]
}
